<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rogue N'Roll</title>
  <link rel="stylesheet" href="styles.css"/>
</head>
<body>
  <div style="position: relative;">
    <div style="display: flex; flex-direction:column;">
      <div style="position: relative;">
        <canvas id="game"></canvas>
      </div>
      <textarea id="log" readonly class="box-boder" style="background:#000; color: #0f0; height: 100px;"></textarea>
    </div>
    <div id="menu" class="box-boder" style="position: absolute; top:20px; left: 20px; right: 20px; bottom: 20px;display: none;">
      <button style="background: transparent;width: 40px;height: 40px;color: #0f0;border: none;font-size: 22px;" onclick="closeMenu()">X</button>
      <div id="menu_char_div" style="margin-bottom: 1rem;width: 100%;">
      </div>
      <div style="margin-left:1rem;color: #0f0;font-weight:bold;font-size: 22sp;">Passivas</div>
      <canvas id="menu_canvas">
      </canvas>
    </div>
    <canvas id="description_canvas" style="position:absolute; top:0; left:0; right: 0;bottom: 0;"></canvas>

    <div id="char_select" class="box-boder" style="position: absolute; top:20px; left: 20px; right: 20px; bottom: 20px;display: flex; flex-direction: column;">
      <h1 style="margin-left: 10px;">Selecione até 3 personagens</h1>
      <div id="char_select_inner" style="overflow: scroll;">
      </div>
      <div style="display: flex;margin-bottom: 10px;">
        <div class="common-button" style="width: 50%;margin-left: 10px;" onclick="openHowTo()">Como jogar?</div>
        <div class="common-button" style="width: 50%;margin-left: 10px;" onclick="openRanking()">Hall da fama</div>
      </div>
      <div class="common-button" style="margin-top:auto;width: calc(100% - 20px);margin-left: 10px;margin-bottom: 10px;" onclick="confirmCharacters()">Começar</div>
    </div>

    <div id="level_up" class="box-boder" style="position: absolute; top:20px; left: 20px; right: 20px; bottom: 20px;display: none;">
      <div style="display: flex; align-items: center;">
        <h1 style="margin-left: auto; margin-right: auto;">Novo nível alcançado!</h1>
        <div class="common-button" style="margin-right: 10px; padding-left: 10px; padding-right: 10px;" onclick="confirmLevelUp()">Confirmar</div>
      </div>
      <div id="level_up_content" style="overflow:scroll;">
      </div>
    </div>

    <div id="how_to" class="box-boder" style="position: absolute; top:20px; left: 20px; right: 20px; bottom: 20px;background: #222;display: none;">
    </div>

    <div id="hall_of_fame" class="box-boder" style="position: absolute; top:20px; left: 20px; right: 20px; bottom: 20px;background: #222;display: none;padding: 20px;">
      <div style="display: flex; align-items: center;">
        <h1 style="margin-left: auto;margin-right: auto;">Hall da Fama</h1>
        <button style="background: transparent;width: 40px;height: 40px;color: #0f0;border: none;font-size: 22px;padding-right: 40px;" onclick="closeRanking()">X</button>
      </div>
      <div id="ranking_content" style="overflow: scroll;"></div>
    </div>
  </div>
</body>
<script type="text/javascript" src="globals.js"></script>
<script>
/* ================== GLOBAL CONSTANTS/FUNCTIONS ================== */

  const FPS = 30;
  const TICK_TIME = FPS/1000.0;
  const BACKGROUND_COLOR = '#222'


  const drawSprite = (x,y,sheet,i,dCtx=ctx,cutW=null,cutH=null,resW=null,resH=null)=>{
    const size = sheet.height; 
    if(cutW == null) {
      cutW = size;
    }
    if(cutH == null) {
      cutH = size;
    }
    if(resW == null) {
      resW = cutW;
    }
    if(resH == null) {
      resH = cutH;
    }
    dCtx.drawImage(sheet,i*size,0,cutW,cutH,x,y,resW,resH);
  }

  function setFontSize(size, dCtx=ctx) {
    dCtx.font = `${size}px pixel`;
  }
</script>
<script type="text/javascript" src="dice.js"></script>
<script type="text/javascript" src="enemy.js"></script>
<script type="text/javascript" src="characters.js"></script>
<script type="text/javascript" src="active_cards.js"></script>
<script type="text/javascript" src="passive_cards.js"></script>
<script type="text/javascript" src="abnormal_status.js"></script>
<script type="text/javascript" src="game_context.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript" src="char_select.js"></script>
<script type="text/javascript" src="levelup.js"></script>
<script type="text/javascript" src="how_to_loader.js"></script>
<script type="text/javascript" src="hall_of_fame.js"></script>
<script>
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");
  const logArea = document.getElementById("log");
  const menu = document.getElementById("menu");
  menu.style.backgroundColor = BACKGROUND_COLOR;
  const levelup = document.getElementById("level_up");
  levelup.style.backgroundColor = BACKGROUND_COLOR;
  const descriptionCanvas = document.getElementById("description_canvas");
  const descriptionCtx = descriptionCanvas.getContext("2d");
  const charSelect = document.getElementById("char_select");
  charSelect.style.backgroundColor = BACKGROUND_COLOR;

  const GAME_WIDTH = 800;
  const GAME_HEIGHT = 600;
  const BUTTON_HEIGHT = 50

  var VERTICAL = canvas.width < canvas.height;
  var BUTTON_H_SCALED = BUTTON_HEIGHT * canvas.height/GAME_HEIGHT;
  var WINDOW_HEIGHT;

  function resize() {
    WINDOW_HEIGHT = window.innerHeight;
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight-logArea.clientHeight;
    descriptionCanvas.width = window.innerWidth;
    descriptionCanvas.height = window.innerHeight-logArea.clientHeight;
    VERTICAL = canvas.width < canvas.height;
    BUTTON_H_SCALED = BUTTON_HEIGHT * canvas.height/GAME_HEIGHT;
  }
  window.addEventListener("resize", resize);
  resize();

/* ================== LOG SYSTEM ================== */
  const logLines = [];
  const MAX_LOGS = 50;

  function log(msg, data = null) {
    if(msg == null || msg.length == 0)
      return;
    const text = data ? `${msg} ${JSON.stringify(data)}` : msg;
    console.log("[GAME]", text);
    logLines.push(text);
    if (logLines.length > MAX_LOGS) logLines.shift();

    logArea.value = [...logLines].join("\n");
    logArea.scrollTop = logArea.scrollHeight;
  }

/* ================== UTILS ================== */

  const GAME_PHASES = [
    {name:"roll", desc: "Rolar dado"},
    {name:"decision", desc: "Escolha carta ou continue"},
    {name:"enemy", desc: "Ataque do inimigo"},
    {name:"gameover", desc: "Fim de jogo"},
  ];

  const BUTTONS = [
    { 
      x:310,y:GAME_HEIGHT-BUTTON_HEIGHT,w:180,name:()=>"ROLAR",status:()=>GAME_CONTEXT.phase.name==="roll",
      color:'#2a2',
      effect:()=>{
        rollPlayer(GAME_CONTEXT)
      }
    },
    { 
      x:310,y:GAME_HEIGHT-BUTTON_HEIGHT,w:180,name:()=>"ATACAR",status:()=>GAME_CONTEXT.phase.name==="decision",
      color:'#2a2',
      effect:()=>{
        resolveTurn(GAME_CONTEXT)
      }
    },
    { 
      x:GAME_WIDTH/2-110,y:GAME_HEIGHT-BUTTON_HEIGHT,w:220,name:(context)=>`DEFENDER ${context.enemyRoll}`,status:()=>GAME_CONTEXT.phase.name==="enemy",
      color:'#c70a0a',
      effect:()=>{
        resolveEnemyTurn(GAME_CONTEXT)
      }
    },
    { 
      x:GAME_WIDTH-190,y:GAME_HEIGHT-BUTTON_HEIGHT,w:180,name:(context)=>'MENU',status:()=>true,
      color:'#444',
      effect:()=>{
        openMenu(GAME_CONTEXT);
      }
    },
    { 
      x:GAME_WIDTH/2-110,y:GAME_HEIGHT-BUTTON_HEIGHT,w:220,name:(context)=>"REINICIAR",status:()=>GAME_CONTEXT.phase.name==="gameover",
      color:'#2a2',
      effect:()=>{
        location.reload(true);
      }
    }
  ]
  var ENEMY_POS = [];
  var ACTIVE_POS = [];
  var DESCRIPTION = null;
  var SCORE = 0;
  const ENEMY_POINT = 15;

/* ================== ENEMIES ================== */

  function newEnemy() {
    // let a=rand(1,5), b=rand(a+1,a+3);
    // return {min:a,max:Math.min(b,6),hp:1,data:ENEMIES[9],block:false,effect:1};
    if (Math.random()<0.5) {
      const v=rand(1,6);
      return {min:v,max:v,hp:1,data:ENEMIES[rand(0,ENEMIES.length-1)],block:false,effect:1};
    }
    let a=rand(1,5), b=rand(a+1,a+3);
    return {min:a,max:Math.min(b,6),hp:1,data:ENEMIES[rand(0,ENEMIES.length-1)],block:false,effect:1};
  }

  function spawnEnemies(context) {
    context.enemies=[];
    let amount = rand(context.level,4+context.level)
    for(let i=0;i<amount;i++) {
      context.enemies.push(newEnemy());
    }
    log("Inimigos gerados:", context.enemies.length);
  }

/* ================== FLOW ================== */
  function startRound() {
    log("=== INÍCIO DA RODADA | Fase " + GAME_CONTEXT.level + " ===");
    spawnEnemies(GAME_CONTEXT);
    positionsEnemies(GAME_CONTEXT);
    const cards = context_renewCards(GAME_CONTEXT,3);
    log(`Nova carta ativa: ${cards}`);
    positionActiveCards(GAME_CONTEXT);
    context_resetTurn(GAME_CONTEXT);
  }

  function START_GAME() {
    // for(let i=0; i < 100; i++)
    //   newPassiveCard(GAME_CONTEXT,GAME_CONTEXT.characters[0].passives);
    startRound();
    requestAnimationFrame(loop);
  }

  function positionsEnemies(context) {
    ENEMY_POS = [];
    let e_line = 12;
    if(VERTICAL)
      e_line = 4;
    let lines = context.enemies.length/e_line;
    let e_b_y = canvas.height/2-60*lines;
    context.enemies.forEach((e,i)=>{
      const line = Math.floor(i/e_line);
      const ex=canvas.width/2-Math.min(context.enemies.length-line*e_line,e_line)*40+(i%e_line)*80;
      let ey = e_b_y + line*70;

      ENEMY_POS.push({
        'x':ex,
        'y':ey,
        'enemy':i
      });
    });
  }

  function positionActiveCards(context) {
    ACTIVE_POS = [];
    const totalWidth = ACTIVE_WIDTH * context.activeCards.length + (10*(context.activeCards.length-1));
    context.activeCards.forEach((c,i)=>{
      const cx=canvas.width/2-totalWidth/2+i*(ACTIVE_WIDTH+10);
      const cy = canvas.height-ACTIVE_HEIGHT-50-BUTTON_H_SCALED;

      ACTIVE_POS.push({
        'x':cx,
        'y':cy,
        'index':i
      });
    });
  }

/* ================== GAME LOGIC ================== */
  function rollPlayer(context) {
    let value = abnormal_apply(context, ROLL_TIME);
    value[1].split("\n").forEach(l=>log(l));
    if(value[0] == false) {
      enemyAttack(context);
      return;
    }

    value = context_rollDice(context);

    log(`Jogador rolou: ${value}`);

    value = passive_apply(context, ROLL_TIME);
    value.split("\n").forEach(l=>log(l));
    value = innate_apply(context, ROLL_TIME);
    value.split("\n").forEach(l=>log(l));

    PREVIEW_CONTEXT = previewTurn(context);

    context.phase=GAME_PHASES[1];
  }

  function resolveTurn(context) {
    let logs;
    if(context.playCards.length > 0) {
      context.passedTurn = false;
      logs = context_applyCards(context, true);
      logs.split("\n").forEach(l=>log(l));
    } else {
      context.passedTurn = true;
    }

    let diceValue = context.calcValue;
    log("Resolvendo rodada com valor final:", diceValue);
    let killed=false;

    context.enemies.forEach(e=>{
      if(enemy_die(e,context)) {
        e.hp=0;
        killed=true;
        context.turnKill += 1;
        if(diceValue == e.min || diceValue == e.max) {
          context.turnCritic += 1;
          log(`Inimigo derrotado: ${e.min}-${e.max}, ataque CRÍTICO!`); 
        } else {
          log(`Inimigo derrotado: ${e.min}-${e.max}`); 
        }
      }
    });

    if(context.turnKill == 0) {
      log("Ataque falhou");
    }

    SCORE += context.turnKill*context.level*(ENEMY_POINT*context.turnKill);

    context.enemies = context.enemies.filter(e=>e.hp>0);

    logs = abnormal_apply(context, END_ATTACK);
    logs[1].split("\n").forEach(l=>log(l));
    if(logs[0]) {
      logs = passive_apply(context, END_ATTACK);
      logs.split("\n").forEach(l=>log(l));
      logs = innate_apply(context, END_ATTACK);
      logs.split("\n").forEach(l=>log(l));
    }

    logs = abnormal_off(context, END_ATTACK);
    logs.split("\n").forEach(l=>log(l));

    if(killed) {
      endTurn(context);
      if(context.enemies.length===0) {
        nextLevel(context);
      } else {
        positionsEnemies(context);
      }
    } else {
      enemyAttack(context);
    }
  }

  function nextLevel(context) {
    let logs = abnormal_apply(context, END_ROUND_TIME);
    logs[1].split("\n").forEach(l=>log(l));

    if(logs[0]) {
      logs = passive_apply(context, END_ROUND_TIME);
      logs.split("\n").forEach(l=>log(l));
      logs = innate_apply(context, END_ROUND_TIME);
      logs.split("\n").forEach(l=>log(l));
    }

    logs = abnormal_off(context, END_ROUND_TIME);
    logs.split("\n").forEach(l=>log(l));

    openLevelup(context);
  }

  function continueNextLevel(logs) {
    logs.split("\n").forEach(l=>log(l));

    context_addLevel(GAME_CONTEXT);
    startRound();
  }

  function enemyAttack(context) {
    context.phase = GAME_PHASES[2];

    const capableEnemies = context.enemies.filter((e)=>e.block==false);

    if(capableEnemies.length == 0) {
      log('Inimigos bloqueados');
      endTurn(context);
      return;
    }

    const totalEffect = capableEnemies.reduce((accumulator, ene) => {
      return accumulator + ene.effect;
    }, 0);
    const minDamage = context.level;
    const maxDamage = totalEffect * context.level;

    context.enemyRoll = context.level + totalEffect;//rand(minDamage, maxDamage);

    let logs = abnormal_apply(context, ENEMY_TIME);
    logs[1].split("\n").forEach(l=>log(l));
    if(logs[0]) {
      logs = passive_apply(context, ENEMY_TIME);
      logs.split("\n").forEach(l=>log(l));
      logs = innate_apply(context, ENEMY_TIME);
      logs.split("\n").forEach(l=>log(l));
    }

    logs = enemy_pasive_apply(context, ENEMY_TIME);
    logs.split("\n").forEach(l=>log(l));
  }

  function resolveEnemyTurn(context) {
    const before = context.shield;
    const after = context_addShield(context,-context.enemyRoll);
    log(`Inimigo atacou com ${context.enemyRoll}: escudo ${before} - ${after}`);

    if(!checkGameOver(context)) {
      endTurn(context);
    }
  }

  function endTurn(context) {
    if(context.passedTurn) {
      const cards = context_renewCards(context,3);
      log(`Nova carta ativa: ${cards}`);
      positionActiveCards(context);
    }

    let logs = enemy_pasive_apply(context, END_TURN_TIME);
    logs.split("\n").forEach(l=>log(l));

    logs = abnormal_apply(context, END_TURN_TIME);
    logs[1].split("\n").forEach(l=>log(l));
    if(logs[0]) {
      logs = passive_apply(context, END_TURN_TIME);
      logs.split("\n").forEach(l=>log(l));
      logs = innate_apply(context, END_TURN_TIME);
      logs.split("\n").forEach(l=>log(l));
    }

    logs = abnormal_off(context, END_TURN_TIME);
    logs.split("\n").forEach(l=>log(l));

    if(!checkGameOver(context)) {
      context_resetTurn(context);
    }
  }

  function checkGameOver(context) {
    if(context.shield <= 0) {
      log("GAME OVER");
      context.phase=GAME_PHASES[3];

      salvarRank(SCORE);
      return true;
    }
    return false;
  }

/* ================== INPUT ================== */
  canvas.addEventListener("click",function(e) {
    const x=e.clientX,y=e.clientY;

    const scaleX = x * GAME_WIDTH/canvas.width;
    const scaleY = y * GAME_HEIGHT/canvas.height;

    for(let btn of BUTTONS) {
      if(btn.status()) {
        if(scaleX > btn.x && scaleX < btn.x+btn.w) {
          if(scaleY > btn.y && scaleY < btn.y+BUTTON_HEIGHT) {
            btn.effect()
            return;
          }  
        }
      }
    }

    if(GAME_CONTEXT.phase.name === "decision") {
      let logs = abnormal_apply(GAME_CONTEXT, DECISION_TIME);
      logs[1].split("\n").forEach(l=>log(l));
      if(logs[0]) {
        for(const c of ACTIVE_POS) {
          const card = GAME_CONTEXT.activeCards[c.index];
          if(!card.used && active_include(c,GAME_CONTEXT,x,y)) {
            context_playCard(GAME_CONTEXT, card);
            break;
          }
        }
      }
    }
  });

  var descriptionTimeout;
  const DESCRITION_CLEAR_TIME = 2000;
  descriptionCanvas.addEventListener("mousemove",e=>{
    DESCRIPTION = null;
    const cx=e.clientX,cy=e.clientY;

    if(menuOpened) {
      let menuClick = menu_includes(GAME_CONTEXT,cx,cy);
      if(menuClick) {
        DESCRIPTION = menuClick;
        if(descriptionTimeout != null)
          clearTimeout(descriptionTimeout)
        descriptionTimeout = setTimeout(clearDescription, DESCRITION_CLEAR_TIME);
      }
      return;
    }

    let enemyList = GAME_CONTEXT.enemies;
    if(PREVIEW_CONTEXT != null) {
      enemyList = PREVIEW_CONTEXT.enemies;
    }

    for(const e of ENEMY_POS) {
      if(enemy_includes(PREVIEW_CONTEXT?PREVIEW_CONTEXT:GAME_CONTEXT,e,cx,cy)) {
        DESCRIPTION = {
          'x':cx,
          'y':cy,
          'drawFunc':drawEnemyDescription,
          'enemy':enemyList[e.enemy].data
        };
        if(descriptionTimeout != null)
          clearTimeout(descriptionTimeout)
        descriptionTimeout = setTimeout(clearDescription, DESCRITION_CLEAR_TIME);
        return;
      }
    }

    for(const c of ACTIVE_POS) {
      if(active_include(c,GAME_CONTEXT,cx,cy)) {
        DESCRIPTION = {
          'x':cx,
          'y':cy,
          'drawFunc':drawActiveCardDescription,
          'card':GAME_CONTEXT.activeCards[c.index]
        };

        if(descriptionTimeout != null)
          clearTimeout(descriptionTimeout)
        descriptionTimeout = setTimeout(clearDescription, DESCRITION_CLEAR_TIME);
        return;
      }
    }

    const abSize = 28;
    let lx = canvas.width-abSize;
    let ly = canvas.height-BUTTON_H_SCALED-abSize
    for(const ab of Object.values(GAME_CONTEXT.abnormalStatus)) {
      if(cx > lx && cx < lx+abSize && cy > ly && cy < ly+abSize ) {
        DESCRIPTION = {
          'x':cx,
          'y':cy,
          'drawFunc':drawAbnormalDescription,
          'abnormal':ab
        };

        if(descriptionTimeout != null)
          clearTimeout(descriptionTimeout)
        descriptionTimeout = setTimeout(clearDescription, DESCRITION_CLEAR_TIME/10*ab.description.split(" ").length);
        return;
      }
      lx -= abSize;
    }
  });
  descriptionCanvas.addEventListener("click", function(e) {
    const x = e.clientX;
    const y = e.clientY;
    if(menuOpened) {
      descriptionCanvas.style.pointerEvents = 'none';
      const el = document.elementFromPoint(x, y);
      descriptionCanvas.style.pointerEvents = 'auto';
      const menuRect = menu.getBoundingClientRect();

      if(x >= menuRect.left && x <= menuRect.right && y >= menuRect.top && y <= menuRect.bottom) {
        el.dispatchEvent(new MouseEvent('click', {
          bubbles: true,
          cancelable: true,
          clientX: x,
          clientY: y,
          view: window
        }));
      } else {
        closeMenu();
      }
    } else {
      canvas.dispatchEvent(new MouseEvent('click', {
        bubbles: true,
        cancelable: true,
        clientX: x,
        clientY: y,
        view: window
      }));
    }
  });
  var touchStartX =0;
  var touchStartY =0;
  descriptionCanvas.addEventListener('touchstart', (e) => {
    if(menuOpened) {
      touchStartX = e.touches[0].clientX;
      touchStartY = e.touches[0].clientY;
    }
  });
  descriptionCanvas.addEventListener('touchmove', (e) => {
    // e.preventDefault();
    if(menuOpened) {
      const touchX = e.touches[0].clientX;
      const touchY = e.touches[0].clientY;
      menu_scroll(GAME_CONTEXT, touchStartX-touchX,touchStartY-touchY);
      touchStartX = e.touches[0].clientX;
      touchStartY = e.touches[0].clientY;
    }
  });

  function clearDescription() {
    DESCRIPTION = null;
  }

/* ================== DRAW ================== */
  function draw(delta) {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle=BACKGROUND_COLOR;
    ctx.fillRect(0,0,canvas.width,canvas.height);
    let label;

    let contextToUse = GAME_CONTEXT;
    if(PREVIEW_CONTEXT != null) {
      contextToUse = PREVIEW_CONTEXT;
    }

  // Enemies
    ENEMY_POS.forEach(e=>{
      enemy_draw(ctx,e.x,e.y,contextToUse.enemies[e.enemy],contextToUse);
    });

  // Active cards
    ACTIVE_POS.forEach(c=>{
      const card = GAME_CONTEXT.activeCards[c.index];
      active_draw(ctx,c.x,c.y,card,GAME_CONTEXT);
    });

  // ROLLs
    ctx.fillStyle = "#bbb";
    ctx.beginPath();
    ctx.arc(canvas.width/2, canvas.height-50-BUTTON_H_SCALED, 25, 0, 2 * Math.PI);
    ctx.fill();

    drawDice(DICE, ctx, contextToUse.calcValue, delta, canvas.width/2, canvas.height-BUTTON_H_SCALED);

    if(GAME_CONTEXT.rollValue) {
      setFontSize(18);
      ctx.fillStyle="#777";
      label=GAME_CONTEXT.rollValue;
      ctx.fillText(label, canvas.width/2 - ctx.measureText(label).width/2, canvas.height-55-BUTTON_H_SCALED);
    }

  // LIFE
    const size = 35;
    let lx = 10+size+size/2;
    let ly = canvas.height-size*1.5;
    ctx.fillStyle = "red"
    ctx.beginPath();
    ctx.arc(lx-size/2, ly, size, 0, 2 * Math.PI);
    ctx.arc(lx+size/2, ly, size, 0, 2 * Math.PI);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(lx, ly+size/2, size, 0, 2 * Math.PI);
    ctx.fill();

    setFontSize(30);
    ctx.fillStyle="#fff";
    let shieldLabel=GAME_CONTEXT.shield;
    let shieldW = ctx.measureText(shieldLabel).width;
    ctx.fillText(shieldLabel,lx-shieldW,ly+10);
    setFontSize(15);
    shieldLabel=`/${GAME_CONTEXT.maxShield}`;
    shieldW = ctx.measureText(shieldLabel).width;
    ctx.fillText(shieldLabel,lx,ly+10);
    if(GAME_CONTEXT.extraShield > 0) {
      shieldLabel=`+${GAME_CONTEXT.extraShield}`;
      ctx.fillStyle="#99e5e8";
      ctx.fillText(shieldLabel,lx+shieldW,ly+10);
    }
    setFontSize(12);
    ctx.fillStyle="#fff";
    shieldLabel="escudo";
    ctx.fillText(shieldLabel,lx-ctx.measureText(shieldLabel).width/2,ly+30);

  // ABNORMAL

    const abSize = 28;
    lx = canvas.width-abSize;
    ly = canvas.height-BUTTON_H_SCALED-abSize
    Object.values(GAME_CONTEXT.abnormalStatus).forEach((ab,i)=>{
      ab.draw(lx-i*abSize,ly,abSize,abSize);
    });

  // Phase label
    setFontSize(20);
    label = `[FASE ${GAME_CONTEXT.level}]`;
    ctx.fillText(label,canvas.width/2 - ctx.measureText(label).width/2,40);
    setFontSize(22);
    ctx.fillStyle="#f5f5f5";
    label=GAME_CONTEXT.phase.desc;
    ctx.fillText(label, canvas.width/2 - ctx.measureText(label).width/2, 60);
    setFontSize(18);
    ctx.fillStyle="#faefb6";
    label=SCORE;
    ctx.fillText(label, canvas.width/2 - ctx.measureText(label).width/2, 82);

  // BUTTONS
    for(let btn of BUTTONS) {
      if(btn.status()) {
        drawBtn(btn);
      }
    }

  // GAME OVER
    if(GAME_CONTEXT.phase && GAME_CONTEXT.phase.name==="gameover") {
      label = "GAME OVER";
      setFontSize(40);
      let measure = ctx.measureText(label).width;
      ctx.fillStyle="#000";
      ctx.fillRect(canvas.width/2-(measure+20)/2, canvas.height/2-40, measure+20, 50);
      ctx.fillStyle="red";
      ctx.fillText(label,canvas.width/2-measure/2,canvas.height/2);
    }

  // DESCRIPTION
    if(DESCRIPTION != null) {
      DESCRIPTION.drawFunc(DESCRIPTION);
    } else {
      descriptionCtx.clearRect(0,0,descriptionCanvas.width,descriptionCanvas.height);
    }

    // menu_draw(GAME_CONTEXT, delta);

  }

  function drawBtn(btn) {
    ctx.fillStyle = btn.color;
    const scaledX = btn.x * canvas.width / GAME_WIDTH;
    const scaledY = btn.y * canvas.height / GAME_HEIGHT;
    const scaledW = btn.w * canvas.width / GAME_WIDTH;
    const scaledH = BUTTON_HEIGHT * canvas.height / GAME_HEIGHT;

    ctx.fillRect(scaledX,scaledY,scaledW,scaledH);
    ctx.fillStyle="white";
    setFontSize(18);
    const label=btn.name(GAME_CONTEXT);
    ctx.fillText(label,scaledX + scaledW/2 - ctx.measureText(label).width/2, scaledY + scaledH/2 + 8);
  }

  function drawLabelDescription(description) {
    descriptionCtx.clearRect(0,0,descriptionCanvas.width,descriptionCanvas.height);
    const labelImage = breakText(description.label, Math.max(100,canvas.width-description.x), 20, "#fff");

    if(description.x + labelImage.width+16 > canvas.width) {
      description.x = canvas.width-labelImage.width-16;
    }
    if(description.y + labelImage.height+16 > canvas.height) {
      description.y = canvas.height - labelImage.height-16;
    }

    descriptionCtx.fillStyle="#000";
    descriptionCtx.fillRect(description.x, description.y, labelImage.width+16, labelImage.height+16);

    descriptionCtx.drawImage(labelImage, description.x+8, description.y+8);
  }

  function drawEnemyDescription(description) {
    descriptionCtx.clearRect(0,0,descriptionCanvas.width,descriptionCanvas.height);
    const labelImage = breakText(description.enemy.name, Math.max(100,canvas.width-description.x), 20, "#fff");
    let passiveImage;
    if(description.enemy.passive != null) {
      passiveImage = breakText(ENEMIES_PASSIVE[description.enemy.passive].description,Math.max(100,canvas.width-description.x), 16, "#fff");
    }
    let width = labelImage.width+16;
    let height = labelImage.height+16;
    if(passiveImage != null) {
      width = Math.max(width, passiveImage.width+16);
      height += passiveImage.height+36;
    }

    if(description.x + width > canvas.width) {
      description.x = canvas.width-width;
    }
    if(description.y + height > canvas.height) {
      description.y = canvas.height - height;
    }

    descriptionCtx.fillStyle="#000";

    descriptionCtx.fillRect(description.x, description.y, width, labelImage.height+16);
    descriptionCtx.drawImage(labelImage, description.x+8, description.y+8);

    if(passiveImage) {
      descriptionCtx.fillStyle="#a03";
      descriptionCtx.fillRect(description.x, description.y+labelImage.height+16, width, passiveImage.height+36);
      setFontSize(20,descriptionCtx);
      descriptionCtx.fillStyle="#fff";
      descriptionCtx.fillText(`[${ENEMIES_PASSIVE[description.enemy.passive].name}]`,description.x+8,description.y+labelImage.height+34);
      descriptionCtx.drawImage(passiveImage, description.x+8, description.y+labelImage.height+44);
    }
  }

  function drawAbnormalDescription(description) {
    descriptionCtx.clearRect(0,0,descriptionCanvas.width,descriptionCanvas.height);
    const labelImage = breakText(description.abnormal.name, Math.max(100,canvas.width-description.x), 20, "#fff");
    let passiveImage = breakText(description.abnormal.description,Math.max(100,canvas.width-description.x), 16, "#fff");
    let width = labelImage.width+16;
    let height = labelImage.height+16;
    if(passiveImage != null) {
      width = Math.max(width, passiveImage.width+16);
      height += passiveImage.height+36;
    }

    if(description.x + width > canvas.width) {
      description.x = canvas.width-width;
    }
    if(description.y + height > canvas.height) {
      description.y = canvas.height - height;
    }

    descriptionCtx.fillStyle="#000";

    descriptionCtx.fillRect(description.x, description.y, width, labelImage.height+16);
    descriptionCtx.drawImage(labelImage, description.x+8, description.y+8);

    if(passiveImage) {
      descriptionCtx.fillStyle="#8800ff";
      descriptionCtx.fillRect(description.x, description.y+labelImage.height+16, width, passiveImage.height+16);
      descriptionCtx.drawImage(passiveImage, description.x+8, description.y+labelImage.height+24);
    }
  }

  function drawActiveCardDescription(description) {
    descriptionCtx.clearRect(0,0,descriptionCanvas.width,descriptionCanvas.height);
    const labelImage = breakText(description.card.name, Math.max(100,canvas.width-description.x), 20, "#fff");
    let passiveImage = breakText(description.card.description,Math.max(100,canvas.width-description.x), 16, "#fff");
    let width = labelImage.width+16;
    let height = labelImage.height+16;
    if(passiveImage != null) {
      width = Math.max(width, passiveImage.width+16);
      height += passiveImage.height+36;
    }

    if(description.x + width > canvas.width) {
      description.x = canvas.width-width;
    }
    if(description.y + height > canvas.height) {
      description.y = canvas.height - height;
    }

    descriptionCtx.fillStyle="#000";

    descriptionCtx.fillRect(description.x, description.y, width, labelImage.height+16);
    descriptionCtx.drawImage(labelImage, description.x+8, description.y+8);

    if(passiveImage) {
      descriptionCtx.fillStyle="#002aff";
      descriptionCtx.fillRect(description.x, description.y+labelImage.height+16, width, passiveImage.height+16);
      descriptionCtx.drawImage(passiveImage, description.x+8, description.y+labelImage.height+24);
    }
  }

  var lastTime = null;
  function loop() {
    if(GAME_CONTEXT.phase == null) {
      return;
    }
    const timeNow = Date.now();
    let timePass = 0;
    if(lastTime != null) {
      timePass = timeNow - lastTime;
    }
    lastTime = timeNow;
    draw(timePass*TICK_TIME);

    if(GAME_CONTEXT.phase != null || GAME_CONTEXT.phase.name!=="gameover") {
      requestAnimationFrame(loop);
    }
  }
</script>
<script>
  function playGame() {
    if(!ENEMY_LOADED || !CHARACTERS_LOADED  || !ABNORMAL_LOADED) {
      return;
    }
  }

  if(ENEMY_LOADED && CHARACTERS_LOADED && ABNORMAL_LOADED) {
    playGame();
  }

  function confirmCharacters() {
    if(Object.values(SELECTED_CHARS).length > 0) {
      context_setCharacters(GAME_CONTEXT,Object.values(SELECTED_CHARS));
      charSelect.style.display = 'none';
      START_GAME(); 
    }
  }
</script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-analytics-compat.js"></script>

<script>
  const firebaseConfig = {
    apiKey: "AIzaSyBaPfwWFVAiyCuzGwlMHsYpqwbh2Nss9nU",
    authDomain: "robguenroll.firebaseapp.com",
    projectId: "robguenroll",
    appId: "1:553039502742:web:c0c14333e5dbb993de51b7",
    measurementId: "G-2T37SS1K1M",
    databaseURL: "https://robguenroll-default-rtdb.firebaseio.com/"
  };

  // Initialize Firebase
  firebase.initializeApp(firebaseConfig);

  firebase.auth().signInAnonymously();
  const analytics = firebase.analytics();

  const db = firebase.database();

  function salvarRank(value) {
    if(value > 0) {
      const user = firebase.auth().currentUser;
      if (!user) return;
      
      const ref = db.ref(`ranking/${user.uid}`);

      ref.once("value").then((snapshot) => {
        const data = snapshot.val();

        if (data == null || value > data.score) {
          const name = prompt("Digite seu nome:");
          if(name != null) {
            ref.update({
              name: name,
              score: value,
              time:Date.now(),
              characters: GAME_CONTEXT.characters.map(c => c.pos).join('_')
            });
          }
        }
      });
    }
  }

  async function getRanking() {
    return await firebase
    .database()
    .ref("ranking")
    .orderByChild("score")
    .limitToLast(10)
    .once("value");
  }

  async function selfRanking() {
      const user = firebase.auth().currentUser;
      if (!user) return null;

      const ref = await db.ref(`ranking/${user.uid}`).once("value");
      if(ref != null && ref.val() != null) {
        const value = {...ref.val(),'user':user.uid};

        return value;
      }
      return null;
  }
</script>