<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rogue N'Roll</title>
  <link rel="stylesheet" href="styles.css"/>
</head>
<body>
  <div style="position: relative;">
    <div style="display: flex; flex-direction:column;">
      <div style="position: relative;">
        <canvas id="game"></canvas>
      </div>
      <textarea id="log" readonly class="box-boder" style="background:#000; color: #0f0; height: 100px;"></textarea>
    </div>
    <div id="menu" class="box-boder" style="position: absolute; top:20px; left: 20px; right: 20px; bottom: 20px;display: none;">
      <button style="background: transparent;width: 40px;height: 40px;color: #0f0;border: none;font-size: 22px;" onclick="closeMenu()">X</button>
      <div id="menu_char_div" style="margin-bottom: 1rem;width: 100%;">
      </div>
      <div style="margin-left:1rem;color: #0f0;font-weight:bold;font-size: 22sp;">Passivas</div>
      <canvas id="menu_canvas">
      </canvas>
    </div>
    <canvas id="description_canvas" style="position:absolute; top:0; left:0; right: 0;bottom: 0;"></canvas>
    <div id="char_select" class="box-boder" style="position: absolute; top:20px; left: 20px; right: 20px; bottom: 20px;display: flex; flex-direction: column;">
      <h1 style="margin-left: 10px;">Selecione até 3 personagens</h1>
      <div id="char_select_inner" style="overflow: scroll;">
      </div>
      <div class="common-button" style="margin-top:auto;width: calc(100% - 20px);margin-left: 10px;margin-bottom: 10px;" onclick="confirmCharacters()">Confirmar</div>
    </div>
  </div>
</body>
<script>

/* ================== GLOBAL CONSTANTS/FUNCTIONS ================== */

  const FPS = 30;
  const TICK_TIME = FPS/1000.0;

  const ROLL_TIME = 0
  const ENEMY_TIME = 1
  const END_TURN_TIME = 2
  const END_ROUND_TIME = 3

  const BACKGROUND_COLOR = '#222'

  const rand = (a,b)=>{
    if(a==b)
      return a;
    else
      return a+Math.floor(Math.random()*(b-a+1));
  };

  const drawSprite = (x,y,sheet,i,dCtx=ctx,cutW=null,cutH=null)=>{
    const size = sheet.height; 
    if(cutW == null) {
      cutW = size;
    }
    if(cutH == null) {
      cutH = size;
    }
    dCtx.drawImage(sheet,i*size,0,cutW,cutH,x,y,cutW,cutH);
  }
</script>
<script type="text/javascript" src="dice.js"></script>
<script type="text/javascript" src="enemy.js"></script>
<script type="text/javascript" src="characters.js"></script>
<script type="text/javascript" src="active_cards.js"></script>
<script type="text/javascript" src="passive_cards.js"></script>
<script type="text/javascript" src="game_context.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript" src="char_select.js"></script>
<script>
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");
  const logArea = document.getElementById("log");
  const menu = document.getElementById("menu");
  menu.style.backgroundColor = BACKGROUND_COLOR;
  const descriptionCanvas = document.getElementById("description_canvas");
  const descriptionCtx = descriptionCanvas.getContext("2d");
  const charSelect = document.getElementById("char_select");
  charSelect.style.backgroundColor = BACKGROUND_COLOR;

  const GAME_WIDTH = 800;
  const GAME_HEIGHT = 600;
  const BUTTON_HEIGHT = 50

  var VERTICAL = canvas.width < canvas.height;
  var BUTTON_H_SCALED = BUTTON_HEIGHT * canvas.height/GAME_HEIGHT;

  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight-logArea.clientHeight;
    descriptionCanvas.width = window.innerWidth;
    descriptionCanvas.height = window.innerHeight;
    VERTICAL = canvas.width < canvas.height;
    BUTTON_H_SCALED = BUTTON_HEIGHT * canvas.height/GAME_HEIGHT;
  }
  window.addEventListener("resize", resize);
  resize();

/* ================== LOG SYSTEM ================== */
  const logLines = [];
  const MAX_LOGS = 50;

  function log(msg, data = null) {
    if(msg == null || msg.length == 0)
      return;
    const text = data ? `${msg} ${JSON.stringify(data)}` : msg;
    console.log("[GAME]", text);
    logLines.push(text);
    if (logLines.length > MAX_LOGS) logLines.shift();

    logArea.value = [...logLines].join("\n");
    logArea.scrollTop = logArea.scrollHeight;
  }

/* ================== UTILS ================== */

  const GAME_PHASES = [
    {name:"roll", desc: "Rolar dado"},
    {name:"decision", desc: "Escolha carta ou continue"},
    {name:"enemy", desc: "Ataque do inimigo"},
    {name:"gameover", desc: "Fim de jogo"},
  ];

  const BUTTONS = [
    { 
      x:310,y:GAME_HEIGHT-BUTTON_HEIGHT,w:180,name:()=>"ROLAR",status:()=>GAME_CONTEXT.phase.name==="roll",
      color:'#2a2',
      effect:()=>{
        rollPlayer(GAME_CONTEXT)
      }
    },
    { 
      x:310,y:GAME_HEIGHT-BUTTON_HEIGHT,w:180,name:()=>"ATACAR",status:()=>GAME_CONTEXT.phase.name==="decision",
      color:'#2a2',
      effect:()=>{
        resolveTurn(GAME_CONTEXT)
      }
    },
    { 
      x:310,y:GAME_HEIGHT-BUTTON_HEIGHT,w:180,name:(context)=>`DEFENDER ${context.enemyRoll}`,status:()=>GAME_CONTEXT.phase.name==="enemy",
      color:'#c70a0a',
      effect:()=>{
        resolveEnemyTurn(GAME_CONTEXT)
      }
    },
    { 
      x:GAME_WIDTH-190,y:GAME_HEIGHT-BUTTON_HEIGHT,w:180,name:(context)=>'MENU',status:()=>true,
      color:'#444',
      effect:()=>{
        openMenu(GAME_CONTEXT);
      }
    }
  ]
  var ENEMY_POS = [];
  var ACTIVE_POS = [];
  var DESCRIPTION = null;
  var SCORE = 0;
  const ENEMY_POINT = 15;

/* ================== ENEMIES ================== */

  function newEnemy() {
    if (Math.random()<0.5) {
      const v=rand(1,6);
      return {min:v,max:v,hp:1,data:ENEMIES[rand(0,ENEMIES.length-1)]};
    }
    let a=rand(1,5), b=rand(a+1,a+3);
    return {min:a,max:Math.min(b,6),hp:1,data:ENEMIES[rand(0,ENEMIES.length-1)]};
  }

  function spawnEnemies(context) {
    context.enemies=[];
    let amount = rand(context.level,4+context.level)
    for(let i=0;i<amount;i++)
      context.enemies.push(newEnemy());
    log("Inimigos gerados:", context.enemies.length);
  }

/* ================== FLOW ================== */
  function startRound() {
    log("=== INÍCIO DA RODADA | Fase " + GAME_CONTEXT.level + " ===");
    spawnEnemies(GAME_CONTEXT);
    positionsEnemies(GAME_CONTEXT);
    const cards = context_renewCards(GAME_CONTEXT,3);
    log(`Nova carta ativa: ${cards}`);
    positionActiveCards(GAME_CONTEXT);
    context_resetTurn(GAME_CONTEXT);
  }

  function START_GAME() {
    // for(let i=0; i < 100; i++)
    //   newPassiveCard(GAME_CONTEXT,GAME_CONTEXT.characters[0].passives);
    startRound();
    requestAnimationFrame(loop);
  }

  function positionsEnemies(context) {
    ENEMY_POS = [];
    let e_line = 12;
    if(VERTICAL)
      e_line = 4;
    let lines = context.enemies.length/e_line;
    let e_b_y = canvas.height/2-60*lines;
    context.enemies.forEach((e,i)=>{
      const line = Math.floor(i/e_line);
      const ex=canvas.width/2-Math.min(context.enemies.length-line*e_line,e_line)*40+(i%e_line)*80;
      let ey = e_b_y + line*70;

      ENEMY_POS.push({
        'x':ex,
        'y':ey,
        'enemy':e
      });
    });
  }

  function positionActiveCards(context) {
    ACTIVE_POS = [];
    const totalWidth = ACTIVE_WIDTH * context.activeCards.length + (10*(context.activeCards.length-1));
    context.activeCards.forEach((c,i)=>{
      const cx=canvas.width/2-totalWidth/2+i*(ACTIVE_WIDTH+10);
      const cy = canvas.height-ACTIVE_HEIGHT-50-BUTTON_H_SCALED;

      ACTIVE_POS.push({
        'x':cx,
        'y':cy,
        'index':i
      });
    });
  }

/* ================== GAME LOGIC ================== */
  function rollPlayer(context) {
    // context_resetTurn(context);
    let value = context_rollDice(context);

    log(`Jogador rolou: ${value}`);

    value = passive_apply(context, ROLL_TIME);
    value.split("\n").forEach(l=>log(l));
    value = innate_apply(context, ROLL_TIME);
    value.split("\n").forEach(l=>log(l));

    context.phase=GAME_PHASES[1];
  }

  function resolveTurn(context) {
    let logs;
    if(context.playCards.length > 0) {
      context.passedTurn = false;
      logs = context_applyCards(context, true);
      logs.split("\n").forEach(l=>log(l));
      context.playCards = [];
    } else {
      context.passedTurn = true;
    }

    let diceValue = context.calcValue;
    log("Resolvendo rodada com valor final:", diceValue);
    let killed=false;

    context.enemies.forEach(e=>{
      if(enemy_die(e,diceValue)) {
        e.hp=0;
        killed=true;
        context.turnKill += 1;
        if(diceValue == e.min || diceValue == e.max) {
          context.turnCritic += 1;
          log(`Inimigo derrotado: ${e.min}-${e.max}, ataque CRÍTICO!`); 
        } else {
          log(`Inimigo derrotado: ${e.min}-${e.max}`); 
        }
      }
    });

    if(context.turnKill == 0) {
      log("Ataque falhou");
    }

    SCORE += context.turnKill*context.level*(ENEMY_POINT*context.turnKill);

    context.enemies = context.enemies.filter(e=>e.hp>0);

    logs = passive_apply(context, END_TURN_TIME);
    logs.split("\n").forEach(l=>log(l));
    logs = innate_apply(context, END_TURN_TIME);
    logs.split("\n").forEach(l=>log(l));

    if(killed) {
      if(context.enemies.length===0) {
        nextLevel(context);
      } else {
        context_resetTurn(context);
        positionsEnemies(context);
      }
    } else {
      enemyAttack(context);
    }
  }

  function nextLevel(context) {
    logs = passive_apply(context, END_ROUND_TIME);
    logs.split("\n").forEach(l=>log(l));
    logs = innate_apply(context, END_ROUND_TIME);
    logs.split("\n").forEach(l=>log(l));

    const char = context.characters[rand(0,context.characters.length-1)];
    for(let i=0; i < context.levelToUp;i++) {
      const charLevel = context_levelCharacter(context, char);
      log(`Subiu de nível: ${charLevel}`);
      const card = newPassiveCard(context,char.passives);
      log(`Nova passiva: ${card.name}`);
    }
    
    context_addLevel(context);
    startRound();
  }

  function enemyAttack(context) {
    context.phase = GAME_PHASES[2]

    const minDamage = context.level;
    const maxDamage = context.enemies.length * context.level;

    context.enemyRoll = rand(minDamage, maxDamage);

    logs = passive_apply(context, ENEMY_TIME);
    logs.split("\n").forEach(l=>log(l));
    logs = innate_apply(context, ENEMY_TIME);
    logs.split("\n").forEach(l=>log(l));
  }

  function resolveEnemyTurn(context) {
    const before = context.shield;
    const after = context_addShield(context,-context.enemyRoll);
    log(`Inimigo atacou com ${context.enemyRoll}: escudo ${before} - ${after}`);

    if(after<=0) {
      log("GAME OVER");
      context.phase=GAME_PHASES[3];
    } else {
      if(context.passedTurn) {
        const cards = context_renewCards(context,3);
        log(`Nova carta ativa: ${cards}`);
        positionActiveCards(context);
      }
      context_resetTurn(context);
    }
  }

/* ================== INPUT ================== */
  canvas.addEventListener("click",function(e) {
    const x=e.clientX,y=e.clientY;

    const scaleX = x * GAME_WIDTH/canvas.width;
    const scaleY = y * GAME_HEIGHT/canvas.height;

    for(let btn of BUTTONS) {
      if(btn.status()) {
        if(scaleX > btn.x && scaleX < btn.x+btn.w) {
          if(scaleY > btn.y && scaleY < btn.y+BUTTON_HEIGHT) {
            btn.effect()
            return;
          }  
        }
      }
    }

    if(GAME_CONTEXT.phase.name === "decision") {
      for(const c of ACTIVE_POS) {
        const card = GAME_CONTEXT.activeCards[c.index];
        if(!card.used && active_include(c,GAME_CONTEXT,x,y)) {
          context_playCard(GAME_CONTEXT, card);
          break;
        }
      }
    }
  });

  var descriptionTimeout;
  const DESCRITION_CLEAR_TIME = 2000;
  descriptionCanvas.addEventListener("mousemove",e=>{
    DESCRIPTION = null;
    const cx=e.clientX,cy=e.clientY;

    if(menuOpened) {
      let menuClick = menu_includes(GAME_CONTEXT,cx,cy);
      if(menuClick) {
        DESCRIPTION = menuClick;
        if(descriptionTimeout != null)
          clearTimeout(descriptionTimeout)
        descriptionTimeout = setTimeout(clearDescription, DESCRITION_CLEAR_TIME);
      }
      return;
    }

    for(const e of ENEMY_POS) {
      if(enemy_includes(e,GAME_CONTEXT.previewValue,cx,cy)) {
        DESCRIPTION = {
          'x':cx,
          'y':cy,
          'label':e.enemy.data.name
        };
        if(descriptionTimeout != null)
          clearTimeout(descriptionTimeout)
        descriptionTimeout = setTimeout(clearDescription, DESCRITION_CLEAR_TIME);
        return;
      }
    }

    for(const c of ACTIVE_POS) {
      if(active_include(c,GAME_CONTEXT,cx,cy)) {
        DESCRIPTION = {
          'x':cx,
          'y':cy,
          'label':GAME_CONTEXT.activeCards[c.index].description
        };

        if(descriptionTimeout != null)
          clearTimeout(descriptionTimeout)
        descriptionTimeout = setTimeout(clearDescription, DESCRITION_CLEAR_TIME);
        return;
      }
    }
  });
  descriptionCanvas.addEventListener("click", function(e) {
    const x = e.clientX;
    const y = e.clientY;
    if(menuOpened) {
      descriptionCanvas.style.pointerEvents = 'none';
      const el = document.elementFromPoint(x, y);
      descriptionCanvas.style.pointerEvents = 'auto';
      const menuRect = menu.getBoundingClientRect();

      if(x >= menuRect.left && x <= menuRect.right && y >= menuRect.top && y <= menuRect.bottom) {
        el.dispatchEvent(new MouseEvent('click', {
          bubbles: true,
          cancelable: true,
          clientX: x,
          clientY: y,
          view: window
        }));
      } else {
        closeMenu();
      }
    } else {
      canvas.dispatchEvent(new MouseEvent('click', {
        bubbles: true,
        cancelable: true,
        clientX: x,
        clientY: y,
        view: window
      }));
    }
  });
  descriptionCanvas.addEventListener('wheel', (e) => {
    if(menuOpened) {
      menu_scroll(GAME_CONTEXT, e);
    }
  });

  function clearDescription() {
    DESCRIPTION = null;
  }

/* ================== DRAW ================== */
  function draw(delta) {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle=BACKGROUND_COLOR;
    ctx.fillRect(0,0,canvas.width,canvas.height);
    let label;

  // Enemies
    ENEMY_POS.forEach(e=>{
      enemy_draw(ctx,e.x,e.y,e.enemy,GAME_CONTEXT.previewValue);
    });

  // Active cards
    ACTIVE_POS.forEach(c=>{
      const card = GAME_CONTEXT.activeCards[c.index];
      active_draw(ctx,c.x,c.y,card,GAME_CONTEXT);
    });

  // ROLLs
    ctx.fillStyle = "#bbb";
    ctx.beginPath();
    ctx.arc(canvas.width/2, canvas.height-50-BUTTON_H_SCALED, 25, 0, 2 * Math.PI);
    ctx.fill();

    drawDice(DICE, ctx, GAME_CONTEXT.previewValue, delta, canvas.width/2, canvas.height-BUTTON_H_SCALED);

    if(GAME_CONTEXT.rollValue) {
      ctx.font="18px Arial";
      ctx.fillStyle="#777";
      label=GAME_CONTEXT.rollValue;
      ctx.fillText(label, canvas.width/2 - ctx.measureText(label).width/2, canvas.height-55-BUTTON_H_SCALED);
    }

  // LIFE
    const size = 35;
    const lx = 10+size+size/2;
    const ly = canvas.height-size*1.5;
    ctx.fillStyle = "red"
    ctx.beginPath();
    ctx.arc(lx-size/2, ly, size, 0, 2 * Math.PI);
    ctx.arc(lx+size/2, ly, size, 0, 2 * Math.PI);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(lx, ly+size/2, size, 0, 2 * Math.PI);
    ctx.fill();

    ctx.font="30px Arial";
    ctx.fillStyle="#fff";
    let shieldLabel=GAME_CONTEXT.shield;
    let shieldW = ctx.measureText(shieldLabel).width;
    ctx.fillText(shieldLabel,lx-shieldW,ly+10);
    ctx.font="15px Arial";
    shieldLabel=`/${GAME_CONTEXT.maxShield}`;
    ctx.fillText(shieldLabel,lx,ly+10);
    ctx.font="12px Arial";
    ctx.fillStyle="#fff";
    shieldLabel="escudo";
    ctx.fillText(shieldLabel,lx-ctx.measureText(shieldLabel).width/2,ly+30);

    ctx.font="20px Arial";
    if(VERTICAL)
      ctx.fillText(`Fase ${GAME_CONTEXT.level}`,canvas.width-100,canvas.height-BUTTON_H_SCALED - 8);
    else
      ctx.fillText(`Fase ${GAME_CONTEXT.level}`,lx+size*2+10,ly+12);

  // Phase label
    ctx.font="22px Arial";
    ctx.fillStyle="#f5f5f5";
    label=GAME_CONTEXT.phase.desc;
    ctx.fillText(label, canvas.width/2 - ctx.measureText(label).width/2, 40);
    ctx.font="18px Arial";
    ctx.fillStyle="#faefb6";
    label=SCORE;
    ctx.fillText(label, canvas.width/2 - ctx.measureText(label).width/2, 62);

  // BUTTONS
    for(let btn of BUTTONS) {
      if(btn.status()) {
        drawBtn(btn);
      }
    }

  // GAME OVER
    if(GAME_CONTEXT.phase && GAME_CONTEXT.phase.name==="gameover") {
      ctx.fillStyle="#000";
      ctx.fillRect(canvas.width/2-140, canvas.height/2-40, 280, 50);
      ctx.fillStyle="red";
      ctx.font="40px Arial";
      ctx.fillText("GAME OVER",canvas.width/2-120,canvas.height/2);
    }

  // DESCRIPTION
    if(DESCRIPTION != null) {
      descriptionCtx.clearRect(0,0,descriptionCanvas.width,descriptionCanvas.height);
      descriptionCtx.font="20px Arial";
      const dsize = descriptionCtx.measureText(DESCRIPTION.label).width+8;
      let rwidth = Math.min(canvas.width-DESCRIPTION.x,dsize);
      if(rwidth != dsize && rwidth < canvas.width/2) {
        rwidth = canvas.width/2;
        DESCRIPTION.x = canvas.width-rwidth;
      }
      const spaceSize = descriptionCtx.measureText(" ").width;
      let rheight = 30;
      if(rwidth < dsize) {
        rheight = Math.ceil(dsize/rwidth)*30;
      }
      descriptionCtx.fillStyle="#000";

      descriptionCtx.fillRect(DESCRIPTION.x, DESCRIPTION.y, rwidth, rheight);
      descriptionCtx.fillStyle="#fff";
      const labels = DESCRIPTION.label.split(" ");
      let x = DESCRIPTION.x+4;
      let y = DESCRIPTION.y;
      labels.forEach((label,i)=> {
        if(x + descriptionCtx.measureText(label).width > canvas.width) {
          x = DESCRIPTION.x+4;
          y += 30;
        }
        descriptionCtx.fillText(label,x, y+20);
        x += descriptionCtx.measureText(label).width+spaceSize;
        if(x > canvas.width) {
          x = DESCRIPTION.x+4;
          y += 30;
        }
      });
    } else {
      descriptionCtx.clearRect(0,0,descriptionCanvas.width,descriptionCanvas.height);
    }

    // menu_draw(GAME_CONTEXT, delta);

  }

  function drawBtn(btn) {
    ctx.fillStyle = btn.color;
    const scaledX = btn.x * canvas.width / GAME_WIDTH;
    const scaledY = btn.y * canvas.height / GAME_HEIGHT;
    const scaledW = btn.w * canvas.width / GAME_WIDTH;
    const scaledH = BUTTON_HEIGHT * canvas.height / GAME_HEIGHT;

    ctx.fillRect(scaledX,scaledY,scaledW,scaledH);
    ctx.fillStyle="white";
    ctx.font="16px Arial";
    const label=btn.name(GAME_CONTEXT);
    const labels = btn.name(GAME_CONTEXT).split(" ");
    labels.forEach((label,i)=> {
      ctx.fillText(label,scaledX + scaledW/2 - ctx.measureText(label).width/2, scaledY + scaledH/2 + i*18 + 8);
    });
  }

  var lastTime = null;
  function loop() {
    if(GAME_CONTEXT.phase == null) {
      return;
    }
    const timeNow = Date.now();
    let timePass = 0;
    if(lastTime != null) {
      timePass = timeNow - lastTime;
    }
    lastTime = timeNow;
    draw(timePass*TICK_TIME);

    if(GAME_CONTEXT.phase != null || GAME_CONTEXT.phase.name!=="gameover") {
      requestAnimationFrame(loop);
    }
  }
</script>
<script>
  function playGame() {
    if(!ENEMY_LOADED || !CHARACTERS_LOADED) {
      return;
    }
  }

  if(ENEMY_LOADED && CHARACTERS_LOADED) {
    playGame();
  }

  function confirmCharacters() {
    if(Object.values(SELECTED_CHARS).length > 0) {
      context_setCharacters(GAME_CONTEXT,Object.values(SELECTED_CHARS));
      charSelect.style.display = 'none';
      START_GAME(); 
    }
  }
</script>