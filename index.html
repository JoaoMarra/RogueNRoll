<!DOCTYPE html>
<html lang="pt-br">
<head>
<meta charset="UTF-8">
<title>Rogue N'Roll</title>
<style>
  body {
    margin: 0;
    background: #111;
    overflow: hidden;
    font-family: Arial, sans-serif;
    color: white;
  }
  canvas { display: block; }
</style>
</head>
<body>

<canvas id="game"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener("resize", resize);
resize();

/* ================== LOG SYSTEM ================== */
const logLines = [];
const MAX_LOGS = 50;

function log(msg, data = null) {
  const text = data ? `${msg} ${JSON.stringify(data)}` : msg;
  console.log("[GAME]", text);
  logLines.push(text);
  if (logLines.length > MAX_LOGS) logLines.shift();
}

/* ================== CONTEXT ================== */
const context = {
  level : 1,
  shield : 10,
  rollValue: null,
  calcValue: null,
  phase: null,
  passedTurn: false,
  activeCards: [],
  passiveCards: [],
  enemies: [],
  turnKill: 0,
  enemyRoll:null,
  playCards: []
};

/* ================== UTILS ================== */

const GAME_WIDTH = 800
const GAME_HEIGHT = 600
const DICE_SIZE = 6
const BACKGROUND_COLOR = '#222'

const rand = (a,b)=>Math.floor(Math.random()*(b-a+1))+a;

const normalize = (a)=>{while(a < 0) a+= DICE_SIZE;a = a % DICE_SIZE; if(a==0) a = DICE_SIZE; return a}

const GAME_PHASES = [
  {name:"roll", desc: "Rolar dado"},
  {name:"decision", desc: "Escolha carta ou continue"},
  {name:"enemy", desc: "Ataque do inimigo"},
  {name:"gameover", desc: "Fim de jogo"},
];

const ROLL_TIME = 0
const ENEMY_TIME = 1
const END_TURN_TIME = 2
const END_ROUND_TIME = 3

const BUTTON_HEIGHT = 50
const BUTTONS = [
  { x:350,y:550,w:100,name:"ROLL",status:()=>context.phase.name==="roll",
    effect:()=>{
      rollPlayer(context)
  }},
  { x:350,y:550,w:100,name:"PASS",status:()=>context.phase.name==="decision",
    effect:()=>{
      resolveTurn(context)
  }}
]

/* ================== CARDS ================== */
const AC_CARDS = [
  { name:"+1", effect:(ctx) => ctx.calcValue+1 },
  { name:"+2", effect:(ctx) => ctx.calcValue+2 },
  { name:"-1", effect:(ctx) => ctx.calcValue-1 },
  { name:"-2", effect:(ctx) => ctx.calcValue-2 },
  { name:`set ${Math.ceil(DICE_SIZE/2)}`, effect:(ctx) => Math.ceil(DICE_SIZE/2) },
  { name:"set 1", effect:(ctx) => 1 },
  { name:`set ${DICE_SIZE}`, effect:(ctx) => DICE_SIZE },
  { name:"Rouba vida", effect:(ctx) => {ctx.shield += ctx.calcValue; return ctx.calcValue }},
]
function newActiveCard() {
  const c = AC_CARDS[rand(0,AC_CARDS.length-1)];
  log("Nova carta ativa:", c.name);
  return { ...c, used:false };
}
const PC_CARDS = [
  { name:"Sempre +1", effect:(ctx) => ctx.calcValue+1,time:ROLL_TIME },
  { name:"Sempre -1", effect:(ctx) => ctx.calcValue-1, time:ROLL_TIME },
  { name:"Par +1", effect:(ctx) => ctx.rollValue%2===0?ctx.calcValue+1:ctx.calcValue, time:ROLL_TIME },
  { name:"Impar +1", effect:(ctx) => ctx.rollValue%2===0?ctx.calcValue:ctx.calcValue+1, time:ROLL_TIME },
  { name:"Par -1", effect:(ctx) => ctx.rollValue%2===0?ctx.calcValue-1:ctx.calcValue, time:ROLL_TIME },
  { name:"Impar -1", effect:(ctx) => ctx.rollValue%2===0?ctx.calcValue:ctx.calcValue-1, time:ROLL_TIME },
  { name:"Barreira +1", effect:(ctx) => ctx.enemyRoll-1, time:ENEMY_TIME },
  { name:"Escudo +1", effect:(ctx) => ctx.shield+=1, time:END_ROUND_TIME },
  { name:"Roba alma", effect:(ctx) => ctx.shield+=ctx.turnKill, time:END_TURN_TIME },
  { name:"Level +1", effect:(ctx) => ctx.level+=1, time:END_ROUND_TIME },
  { name:"Gambler", effect:(ctx) => refreshCards(ctx,1), time:END_TURN_TIME }
]
function newPassiveCard() {
  const c = PC_CARDS[rand(0,PC_CARDS.length-1)];
  log("Nova carta passiva:", c.name);
  return c;
}

/* ================== ENEMIES ================== */
const ENEMY_DRAW = [
  (x,y,w,h)=> {
    ctx.fillStyle="green";
    const foot = 8
    const body = 20
    const head = 12
    ctx.fillRect(x+w/4-foot/2,y+h-4-foot,foot,foot)
    ctx.fillRect(x+3*w/4-foot/2,y+h-4-foot,foot,foot)
    ctx.fillRect(x+w/2-body/2,y+h-4-foot-body,body,body)
    ctx.fillRect(x+w/2-body/2-foot,y+h-4-foot-body,foot,foot)
    ctx.fillRect(x+w/2-body/2-foot-foot/2,y+h-4-body,foot,foot)
    ctx.fillRect(x+w/2+body/2,y+h-4-foot-body,foot,foot)
    ctx.fillRect(x+w/2+body/2+foot/2,y+h-4-body,foot,foot)
    ctx.fillRect(x+w/2-head/2,y+h-4-body-head-foot,head,head)
    ctx.fillStyle="brown";
    ctx.fillRect(x+w/2-head/2,y+h-2-body-head-foot,head,2)
    ctx.fillStyle="white";
    ctx.fillRect(x+w/2-head/2+2,y+h-body-head-foot,2,2)
    ctx.fillRect(x+w/2+head/2-2,y+h-body-head-foot,2,2)
  }
]
function newEnemy() {
  if (Math.random()<0.5) {
    const v=rand(1,DICE_SIZE);
    return {min:v,max:v,hp:1,draw:ENEMY_DRAW[0]};
  }
  let a=rand(1,DICE_SIZE-1), b=rand(a+1,a+3);
  return {min:a,max:Math.min(b,DICE_SIZE),hp:1,draw:ENEMY_DRAW[0]};
}

function spawnEnemies(ctx) {
  ctx.enemies=[];
  let amount = rand(ctx.level,3+ctx.level)
  for(let i=0;i<amount;i++)
    ctx.enemies.push(newEnemy());
  log("Inimigos gerados:", ctx.enemies.length);
}

/* ================== FLOW ================== */
function startRound() {
  log("=== INÍCIO DA RODADA | Nível " + context.level + " ===");
  spawnEnemies(context);
  renewCards(context);
  resetTurn()
}

function resetTurn() {
  context.rollValue=null;
  context.calcValue=null;
  context.enemyRoll=null;
  context.passedTurn=false;
  context.playCards = []
  context.turnKill = 0;
  context.phase=GAME_PHASES[0];
}

function renewCards(ctx) {
  ctx.activeCards = []
  while(ctx.activeCards.length<3) ctx.activeCards.push(newActiveCard());
}

function refreshCards(ctx,amount) {
  let index = rand(0,ctx.activeCards.length-1)
  if(index < ctx.activeCards.length) {
    ctx.activeCards.splice(index,1,newActiveCard())
  }
}

context.passiveCards.push(newPassiveCard());
startRound();

/* ================== GAME LOGIC ================== */
function rollPlayer(ctx) {
  ctx.passedTurn = false;

  ctx.rollValue = rand(1,DICE_SIZE);
  ctx.calcValue = ctx.rollValue;
  log("Jogador rolou:", ctx.rollValue);

  ctx.passiveCards.forEach(p=>{
    if(p.time == ROLL_TIME) {
      const before=ctx.calcValue;
      ctx.calcValue=p.effect(ctx);
      log(`Passiva ${p.name}:`, {before, after:ctx.calcValue});
    }
  });

  ctx.calcValue=normalize(ctx.calcValue);
  log("Valor final após passivas:", ctx.calcValue);

  ctx.phase=GAME_PHASES[1];
}

function previewTurn(ctx) {
  const ctx2 = {
    ...ctx
  }
  if(ctx.calcValue != null) {
    ctx2.playCards.forEach(p=>{
      const before=ctx2.calcValue;
      ctx2.calcValue=p.effect(ctx2);
    })
    ctx2.calcValue=normalize(ctx2.calcValue);
  }
  return ctx2;
}

function resolveTurn(ctx) {
  if(ctx.playCards.length > 0) {
    ctx.passedTurn = false;
    ctx.playCards.forEach(p=>{
      const before=ctx.calcValue;
      ctx.calcValue=p.effect(ctx);
      log(`Ativa ${p.name}:`, {before, after:ctx.calcValue});
      p.used = true
    })
    ctx.playCards = []
  } else {
    ctx.passedTurn = true;
  }
  ctx.calcValue=normalize(ctx.calcValue)

  let diceValue = ctx.calcValue;
  log("Resolvendo rodada com valor final:", diceValue);
  let killed=false;

  ctx.enemies.forEach(e=>{
    if(enemyDie(e,diceValue)) {
      e.hp=0;
      killed=true;
      log("Inimigo derrotado:", `${e.min}-${e.max}`);
      ctx.turnKill += 1;
    }
  });

  context.enemies=context.enemies.filter(e=>e.hp>0);

  ctx.passiveCards.forEach(p=>{
    if(p.time == END_TURN_TIME) {
      p.effect(ctx);
      log(`Passiva ${p.name}`);
    }
  });

  if(killed) {
    if(context.enemies.length===0) nextLevel(ctx);
    else resetTurn();
  } else {
    enemyAttack(ctx);
  }
}

function enemyDie(e,diceValue) {
  if(diceValue == null)
    return false
  return diceValue>=e.min && diceValue<=e.max;
}

function nextLevel(ctx) {
  ctx.passiveCards.forEach(p=>{
    if(p.time == END_ROUND_TIME) {
      p.effect(ctx);
      log(`Passiva ${p.name}:`);
    }
  });

  ctx.level++;
  log("Subiu de nível:", ctx.level);
  ctx.passiveCards.push(newPassiveCard());
  startRound();
}

function enemyAttack(ctx) {
  ctx.phase = GAME_PHASES[2]

  ctx.enemyRoll=rand(1,ctx.enemies.length+ctx.level/2);
  ctx.passiveCards.forEach(p=>{
    if(p.time == ENEMY_TIME) {
      const before=ctx.enemyRoll;
      ctx.enemyRoll=p.effect(ctx);
      log(`Passiva ${p.name}:`, {before, after:ctx.enemyRoll});
    }
  });

  ctx.shield-=ctx.enemyRoll;
  log("Inimigo atacou:", {roll:ctx.enemyRoll,shield:ctx.shield});

  if(ctx.shield<=0) {
    log("GAME OVER");
    ctx.phase=GAME_PHASES[3];
  } else {
    if(ctx.passedTurn) {
      renewCards(ctx)
    }
    resetTurn();
  }
}

/* ================== INPUT ================== */
canvas.addEventListener("click",e=>{
  const x=e.clientX,y=e.clientY;

  const scaleX = x * GAME_WIDTH/canvas.width;
  const scaleY = y * GAME_HEIGHT/canvas.height;

  for(let btn of BUTTONS) {
    if(btn.status()) {
      if(scaleX > btn.x && scaleX < btn.x+btn.w) {
        if(scaleY > btn.y && scaleY < btn.y+BUTTON_HEIGHT) {
          btn.effect()
          return;
        }  
      }
    }
  }

  const bhScaled = BUTTON_HEIGHT * canvas.height/GAME_HEIGHT;
  if(context.phase.name === "decision") {
    context.activeCards.forEach((c,i) => {
      const cx=canvas.width/2-160+i*110;
      const cy=canvas.height-200-bhScaled;
      if(!c.used && x>cx && x<cx+100 && y>cy && y<cy+120) {
        if(context.playCards.includes(c)) {
        log("Carta removida",{name:c.name})
          context.playCards=context.playCards.filter(item => item !== c)
        } else {
        log("Carta selecionada",{name:c.name})
          context.playCards.push(c)
        }
      }
    });
  }
  
});

/* ================== DRAW ================== */
function draw() {
  const bhScaled = BUTTON_HEIGHT * canvas.height/GAME_HEIGHT;
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle=BACKGROUND_COLOR;
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // Phase label
  ctx.font="22px Arial";
  ctx.fillStyle="#f5f5f5";
  const label=context.phase.desc;
  ctx.fillText(label, canvas.width/2 - ctx.measureText(label).width/2, 40);

  // Passives
  context.passiveCards.forEach((p,i)=>{
    ctx.fillStyle="#444";
    ctx.fillRect(20,100+i*60,160,50);
    ctx.fillStyle="white";
    ctx.fillText(p.name,30,130+i*60);
  });

  const previewValue = previewTurn(context).calcValue
  // Enemies
  const e_line = 12;
  let lines = context.enemies.length/e_line
  let e_b_y = canvas.height/2-60*lines;
  context.enemies.forEach((e,i)=>{
    const line = Math.floor(i/e_line);
    const ex=canvas.width/2-Math.min(context.enemies.length-line*e_line,e_line)*40+(i%e_line)*80;
    let ey = e_b_y + line*70

    drawEnemy(e,previewValue,ex,ey);
  });

  // Active cards
  let cy=canvas.height-170-bhScaled
  if(context.phase.name == "decision") {
    cy = canvas.height-200-bhScaled;
  }
  context.activeCards.forEach((c,i)=>{
    const cx=canvas.width/2-160+i*110;
    if(context.playCards.includes(c)) {
      cy-=10;
      ctx.fillStyle="#2a2";
      ctx.fillRect(cx-3,cy-3,106,126);
    }
    ctx.fillStyle=c.used?"#555":"#3366cc";
    ctx.fillRect(cx,cy,100,120);
    ctx.fillStyle="white";
    ctx.fillText(c.name,cx+20,cy+65);
    if(context.playCards.includes(c)) {
      cy+=10;
    }
  });

  // ROLLs
  ctx.fillStyle = "#bbb";
  ctx.beginPath();
  ctx.arc(canvas.width/2, canvas.height-50-bhScaled, 25, 0, 2 * Math.PI);
  ctx.fill();
  ctx.fillStyle = "#fff";
  ctx.beginPath();
  ctx.arc(canvas.width/2, canvas.height-bhScaled, 50, 0, 2 * Math.PI);
  ctx.fill();

  if(context.rollValue) {
    ctx.font="18px Arial";
    ctx.fillStyle="#777";
    const label=context.rollValue;
    ctx.fillText(label, canvas.width/2 - ctx.measureText(label).width/2, canvas.height-55-bhScaled);
  }

  if(previewValue) {
    ctx.font="22px Arial";
    ctx.fillStyle="#000";
    const label=previewValue;
    ctx.fillText(label, canvas.width/2 - ctx.measureText(label).width/2, canvas.height-20-bhScaled);
  }

  // LIFE
  const size = 35;
  const lx = 20+size+size/2;
  const ly = canvas.height-250-size;
  ctx.fillStyle = "red"
  ctx.beginPath();
  ctx.arc(lx-size/2, ly, size, 0, 2 * Math.PI);
  ctx.arc(lx+size/2, ly, size, 0, 2 * Math.PI);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(lx, ly+size/2, size, 0, 2 * Math.PI);
  ctx.fill();
  ctx.font="30px Arial";
  ctx.fillStyle="#fff";
  let shieldLabel=context.shield;
  ctx.fillText(shieldLabel,lx-ctx.measureText(shieldLabel).width/2,ly+10);
  ctx.font="15px Arial";
  ctx.fillStyle="#fff";
  shieldLabel="escudo";
  ctx.fillText(shieldLabel,lx-ctx.measureText(shieldLabel).width/2,ly+30);
  ctx.font="20px Arial";
  ctx.fillText(`Nível: ${context.level}`,lx+size*2+10,ly+12);

  // BUTTONS
  ctx.font="16px Arial";
  for(let btn of BUTTONS) {
    if(btn.status()) {
      drawBtn(btn);
    }
  }

  // LOG PANEL
  const logX = 20;
  const logY = canvas.height - 220;
  const logW = 380;
  const logH = 200;

  ctx.fillStyle="rgba(0,0,0,0.7)";
  ctx.fillRect(logX, logY, logW, logH);
  ctx.strokeStyle="#666";
  ctx.strokeRect(logX, logY, logW, logH);

  ctx.font="12px Arial";
  ctx.fillStyle="#0f0";
  logLines.slice(-12).forEach((line,i)=>{
    ctx.fillText(line, logX+10, logY+20+i*14);
  });

  if(context.phase && context.phase.name==="gameover") {
    ctx.fillStyle="#000";
    ctx.fillRect(canvas.width/2-140, canvas.height/2-40, 280, 50);
    ctx.fillStyle="red";
    ctx.font="40px Arial";
    ctx.fillText("GAME OVER",canvas.width/2-120,canvas.height/2);
  } else {
    requestAnimationFrame(draw);
  }

}

function drawEnemy(e,previewValue,ex,ey) {
  if(enemyDie(e,previewValue)) {
    ey += 20
    ctx.fillStyle="#888";
  } else {
    ctx.fillStyle="#a03";
  }
  ctx.fillRect(ex,ey,60,80);
  ctx.fillStyle=BACKGROUND_COLOR;
  ctx.fillRect(ex+2,ey+24,56,54);
  ctx.fillStyle="white";
  ctx.font="20px Arial";
  ctx.fillText(
    e.min===e.max?e.min:`${e.min}-${e.max}`,
    ex+4,ey+22
    );

  e.draw(ex+2,ey+24,56,54);
}

function drawBtn(btn) {
  ctx.fillStyle = "#2a2";
  const scaledX = btn.x * canvas.width/GAME_WIDTH;
  const scaledY = btn.y * canvas.height/GAME_HEIGHT;
  const scaledW = btn.w * canvas.width/GAME_WIDTH;
  const scaledH = BUTTON_HEIGHT * canvas.height/GAME_HEIGHT;

  ctx.fillRect(scaledX,scaledY,scaledW,scaledH);
  ctx.fillStyle="white";
  const label=btn.name;
  const measure = ctx.measureText(label);
  ctx.fillText(label,scaledX + scaledW/2 - measure.width/2, scaledY + scaledH/2);
}

requestAnimationFrame(draw);
</script>